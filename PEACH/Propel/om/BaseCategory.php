<?php 

require_once 'propel/om/BaseObject.php';

 

include_once 'propel/util/Criteria.php';
 

// (on-demand) include_once 'PEACH/Propel/Image.php';
// (on-demand) include_once 'PEACH/Propel/ImagePeer.php';
 

// (on-demand) include_once 'PEACH/Propel/Category.php';
// (on-demand) include_once 'PEACH/Propel/CategoryPeer.php';

include_once 'PEACH/Propel/CategoryPeer.php';

/**
 * This class was autogenerated by Propel on:
 *
 * [Fri Jun  4 20:26:28 2004]
 *
 * You should not use this class directly.  It should not even be
 * extended; all references should be to Category class. 
 * 
 * @package PEACH.Propel 
 */
abstract class BaseCategory extends BaseObject {
    
    /** 
     * The Peer class.
     * Instance provides a convenient way of calling static methods on a class
     * that calling code may not be able to identify.
     * @var CategoryPeer
     */
    private static $peer;

    /**
     * The value for the id field.
     * @var int      
     */
    private $id = 0;
      
    /**
     * The value for the title field.
     * @var string      
     */
    private $title;
      
    /**
     * The value for the description field.
     * @var string      
     */
    private $description;
      
    /**
     * The value for the image_id field.
     * @var int      
     */
    private $image_id;
      
    /**
     * The value for the parent_id field.
     * @var int      
     */
    private $parent_id = 0;
      
    /**
     * The value for the children field.
     * @var string      
     */
    private $children;
          
    
  
    /**
     * Get the id      
     *
     * @return int      
     */
    public function getid()
    {
        return $this->id;
    }

    
    /**
     * Set the value of id      
     *
     * @param int $v new value
     * @return void
     * @throws PropelException      
     */
    public function setid($v)
    { 
        if ($this->id !== $v) {
            $this->id = $v;
            $this->modifiedColumns[] = CategoryPeer::ID;
        }
                  
          // update associated Document          
          if ($this->collDocuments !== null) {
              for ($i=0,$size=count($this->collDocuments); $i < $size; $i++) {
                  $this->collDocuments[$i]->setcat_id($v);
              }
          }
                  
          // update associated File          
          if ($this->collFiles !== null) {
              for ($i=0,$size=count($this->collFiles); $i < $size; $i++) {
                  $this->collFiles[$i]->setcat_id($v);
              }
          }
                  
          // update associated Image          
          if ($this->collImages !== null) {
              for ($i=0,$size=count($this->collImages); $i < $size; $i++) {
                  $this->collImages[$i]->setcat_id($v);
              }
          }
                  
          // update associated news          
          if ($this->collnewss !== null) {
              for ($i=0,$size=count($this->collnewss); $i < $size; $i++) {
                  $this->collnewss[$i]->setcat_id($v);
              }
          }
                  
          // update associated page          
          if ($this->collpages !== null) {
              for ($i=0,$size=count($this->collpages); $i < $size; $i++) {
                  $this->collpages[$i]->setcat_id($v);
              }
          }
                      
    }


  
    /**
     * Get the title      
     *
     * @return string      
     */
    public function gettitle()
    {
        return $this->title;
    }

    
    /**
     * Set the value of title      
     *
     * @param string $v new value
     * @return void
     *       
     */
    public function settitle($v)
    { 
        if ($this->title !== $v) {
            $this->title = $v;
            $this->modifiedColumns[] = CategoryPeer::TITLE;
        }
                
    }


  
    /**
     * Get the description      
     *
     * @return string      
     */
    public function getdescription()
    {
        return $this->description;
    }

    
    /**
     * Set the value of description      
     *
     * @param string $v new value
     * @return void
     *       
     */
    public function setdescription($v)
    { 
        if ($this->description !== $v) {
            $this->description = $v;
            $this->modifiedColumns[] = CategoryPeer::DESCRIPTION;
        }
                
    }


  
    /**
     * Get the image_id      
     *
     * @return int      
     */
    public function getimage_id()
    {
        return $this->image_id;
    }

    
    /**
     * Set the value of image_id      
     *
     * @param int $v new value
     * @return void
     * @throws PropelException      
     */
    public function setimage_id($v)
    { 
        if ($this->image_id !== $v) {
            $this->image_id = $v;
            $this->modifiedColumns[] = CategoryPeer::IMAGE_ID;
        }
            
        if ($this->aImage !== null && $this->aImage->getid() !== $v) {
            $this->aImage = null;
        }
            
    }


  
    /**
     * Get the parent_id      
     *
     * @return int      
     */
    public function getparent_id()
    {
        return $this->parent_id;
    }

    
    /**
     * Set the value of parent_id      
     *
     * @param int $v new value
     * @return void
     * @throws PropelException      
     */
    public function setparent_id($v)
    { 
        if ($this->parent_id !== $v) {
            $this->parent_id = $v;
            $this->modifiedColumns[] = CategoryPeer::PARENT_ID;
        }
            
        if ($this->aCategoryRelatedByparent_id !== null && $this->aCategoryRelatedByparent_id->getid() !== $v) {
            $this->aCategoryRelatedByparent_id = null;
        }
            
    }


  
    /**
     * Get the children      
     *
     * @return string      
     */
    public function getchildren()
    {
        return $this->children;
    }

    
    /**
     * Set the value of children      
     *
     * @param string $v new value
     * @return void
     *       
     */
    public function setchildren($v)
    { 
        if ($this->children !== $v) {
            $this->children = $v;
            $this->modifiedColumns[] = CategoryPeer::CHILDREN;
        }
                
    }



    /**
     * @var Image      
     */
    private $aImage;

    /**
     * Declares an association between this object and a Image object
     *
     * @param Image $v
     * @return void
     * @throws PropelException
     */
    public function setImage($v)
    {
            
        if ($v === null) {
            $this->setimage_id(NULL);
        } else {
            $this->setimage_id($v->getid());
        }
      
        $this->aImage = $v;
    }


    /**
     * Get the associated Image object
     *
     * @return Image The associated Image object.
     * @throws PropelException
     */
    public function getImage()
    {
        // include the Peer class
        include_once 'PEACH/Propel/ImagePeer.php';

        if ($this->aImage === null && ($this->image_id !== null)) {
    
            $this->aImage = ImagePeer::retrieveByPK($this->image_id);
    
            /* The following can be used instead of the line above to
               guarantee the related object contains a reference
               to this object, but this level of coupling
               may be undesirable in many circumstances.
               As it can lead to a db query with many results that may
               never be used.
               $obj = ImagePeer::retrieveByPK($this->image_id);
               $obj->addCategorys($this);
             */
        }
        return $this->aImage;
    }

    /**
     * Provides convenient way to set a relationship based on a
     * key.  e.g.
     * <code>$bar->setFooKey($foo->getPrimaryKey())</code>
     *
 
     * @return void
     * @throws PropelException
     */
    public function setImageKey($key)
    {

        $this->setimage_id( (int) $key);            
        
    }

    /**
     * @var Category      
     */
    private $aCategoryRelatedByparent_id;

    /**
     * Declares an association between this object and a Category object
     *
     * @param Category $v
     * @return void
     * @throws PropelException
     */
    public function setCategoryRelatedByparent_id($v)
    {
            
        if ($v === null) {
            $this->setparent_id('0');
        } else {
            $this->setparent_id($v->getid());
        }
      
        $this->aCategoryRelatedByparent_id = $v;
    }


    /**
     * Get the associated Category object
     *
     * @return Category The associated Category object.
     * @throws PropelException
     */
    public function getCategoryRelatedByparent_id()
    {
        // include the Peer class
        include_once 'PEACH/Propel/CategoryPeer.php';

        if ($this->aCategoryRelatedByparent_id === null && ($this->parent_id !== null)) {
    
            $this->aCategoryRelatedByparent_id = CategoryPeer::retrieveByPK($this->parent_id);
    
            /* The following can be used instead of the line above to
               guarantee the related object contains a reference
               to this object, but this level of coupling
               may be undesirable in many circumstances.
               As it can lead to a db query with many results that may
               never be used.
               $obj = CategoryPeer::retrieveByPK($this->parent_id);
               $obj->addCategorysRelatedByparent_id($this);
             */
        }
        return $this->aCategoryRelatedByparent_id;
    }

    /**
     * Provides convenient way to set a relationship based on a
     * key.  e.g.
     * <code>$bar->setFooKey($foo->getPrimaryKey())</code>
     *
 
     * @return void
     * @throws PropelException
     */
    public function setCategoryRelatedByparent_idKey($key)
    {

        $this->setparent_id( (int) $key);            
        
    }

    /**
     * Collection to store aggregation of collDocuments      
     * @var array
     */
    protected $collDocuments; 

    /**
     * Temporary storage of collDocuments to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     * @return void
     */
    public function initDocuments()
    {
        if ($this->collDocuments === null) {
            $this->collDocuments = array();
        }
    }

    /**
     * Method called to associate a Document object to this object
     * through the Document foreign key attribute
     *
     * @param Document $l $className
     * @return void
     * @throws PropelException
     */
    public function addDocument(Document $l)
    {
        $this->collDocuments[] = $l;
        $l->setCategory($this);
    }

    /**
     * The criteria used to select the current contents of collDocuments.
     * @var Criteria
     */
    private $lastDocumentsCriteria = null;

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Category has previously
     * been saved, it will retrieve related ${relCol} from storage.
     * If this Category is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @param Criteria $criteria
     * @throws PropelException
     */
    public function getDocuments($criteria = null)
    {
        if ($criteria === null) {
            $criteria = new Criteria();
        }
                
        if ($this->collDocuments === null) {
            if ($this->isNew()) {
               $this->collDocuments = array();
            } else {
    
                $criteria->add(DocumentPeer::CAT_ID, $this->getid() );

                $this->collDocuments = DocumentPeer::doSelect($criteria);
            }
        } else {
            // criteria has no effect for a new object
            if (!$this->isNew()) {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.

                $criteria->add(DocumentPeer::CAT_ID, $this->getid());

                if (!isset($this->lastDocumentsCriteria) || !$this->lastDocumentsCriteria->equals($criteria)) {
                    $this->collDocuments = DocumentPeer::doSelect($criteria);
                }
            }
        }
        $this->lastDocumentsCriteria = $criteria;

        return $this->collDocuments;
    }
    

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this $table->getPhpName() is new, it will return
     * an empty collection; or if this $table->getPhpName() has previously
     * been saved, it will retrieve related ${relCol} from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Category.
     */
    public function getDocumentsJoinCategory($criteria = null)
    {
		if ($criteria === null) {
            $criteria = new Criteria();
        }
		
        if ($this->collDocuments === null) {
            if ($this->isNew()) {
               $this->collDocuments = array();
            } else {
       
                $criteria->add(DocumentPeer::CAT_ID, $this->getid());
                   $this->collDocuments = DocumentPeer::doSelectJoinCategory($criteria);
            }
        } else {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            $newCriteria = true;
      
                $criteria->add(DocumentPeer::CAT_ID, $this->getid());
               if (!isset($this->lastDocumentsCriteria) || !$this->lastDocumentsCriteria->equals($criteria)) {
                $this->collDocuments = DocumentPeer::doSelectJoinCategory($criteria);
            }
        }
        $this->lastDocumentsCriteria = $criteria;

        return $this->collDocuments;
    }

    /**
     * Collection to store aggregation of collFiles      
     * @var array
     */
    protected $collFiles; 

    /**
     * Temporary storage of collFiles to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     * @return void
     */
    public function initFiles()
    {
        if ($this->collFiles === null) {
            $this->collFiles = array();
        }
    }

    /**
     * Method called to associate a File object to this object
     * through the File foreign key attribute
     *
     * @param File $l $className
     * @return void
     * @throws PropelException
     */
    public function addFile(File $l)
    {
        $this->collFiles[] = $l;
        $l->setCategory($this);
    }

    /**
     * The criteria used to select the current contents of collFiles.
     * @var Criteria
     */
    private $lastFilesCriteria = null;

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Category has previously
     * been saved, it will retrieve related ${relCol} from storage.
     * If this Category is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @param Criteria $criteria
     * @throws PropelException
     */
    public function getFiles($criteria = null)
    {
        if ($criteria === null) {
            $criteria = new Criteria();
        }
                
        if ($this->collFiles === null) {
            if ($this->isNew()) {
               $this->collFiles = array();
            } else {
    
                $criteria->add(FilePeer::CAT_ID, $this->getid() );

                $this->collFiles = FilePeer::doSelect($criteria);
            }
        } else {
            // criteria has no effect for a new object
            if (!$this->isNew()) {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.

                $criteria->add(FilePeer::CAT_ID, $this->getid());

                if (!isset($this->lastFilesCriteria) || !$this->lastFilesCriteria->equals($criteria)) {
                    $this->collFiles = FilePeer::doSelect($criteria);
                }
            }
        }
        $this->lastFilesCriteria = $criteria;

        return $this->collFiles;
    }
    

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this $table->getPhpName() is new, it will return
     * an empty collection; or if this $table->getPhpName() has previously
     * been saved, it will retrieve related ${relCol} from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Category.
     */
    public function getFilesJoinCategory($criteria = null)
    {
		if ($criteria === null) {
            $criteria = new Criteria();
        }
		
        if ($this->collFiles === null) {
            if ($this->isNew()) {
               $this->collFiles = array();
            } else {
       
                $criteria->add(FilePeer::CAT_ID, $this->getid());
                   $this->collFiles = FilePeer::doSelectJoinCategory($criteria);
            }
        } else {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            $newCriteria = true;
      
                $criteria->add(FilePeer::CAT_ID, $this->getid());
               if (!isset($this->lastFilesCriteria) || !$this->lastFilesCriteria->equals($criteria)) {
                $this->collFiles = FilePeer::doSelectJoinCategory($criteria);
            }
        }
        $this->lastFilesCriteria = $criteria;

        return $this->collFiles;
    }

    /**
     * Collection to store aggregation of collImages      
     * @var array
     */
    protected $collImages; 

    /**
     * Temporary storage of collImages to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     * @return void
     */
    public function initImages()
    {
        if ($this->collImages === null) {
            $this->collImages = array();
        }
    }

    /**
     * Method called to associate a Image object to this object
     * through the Image foreign key attribute
     *
     * @param Image $l $className
     * @return void
     * @throws PropelException
     */
    public function addImage(Image $l)
    {
        $this->collImages[] = $l;
        $l->setCategory($this);
    }

    /**
     * The criteria used to select the current contents of collImages.
     * @var Criteria
     */
    private $lastImagesCriteria = null;

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Category has previously
     * been saved, it will retrieve related ${relCol} from storage.
     * If this Category is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @param Criteria $criteria
     * @throws PropelException
     */
    public function getImages($criteria = null)
    {
        if ($criteria === null) {
            $criteria = new Criteria();
        }
                
        if ($this->collImages === null) {
            if ($this->isNew()) {
               $this->collImages = array();
            } else {
    
                $criteria->add(ImagePeer::CAT_ID, $this->getid() );

                $this->collImages = ImagePeer::doSelect($criteria);
            }
        } else {
            // criteria has no effect for a new object
            if (!$this->isNew()) {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.

                $criteria->add(ImagePeer::CAT_ID, $this->getid());

                if (!isset($this->lastImagesCriteria) || !$this->lastImagesCriteria->equals($criteria)) {
                    $this->collImages = ImagePeer::doSelect($criteria);
                }
            }
        }
        $this->lastImagesCriteria = $criteria;

        return $this->collImages;
    }
    

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this $table->getPhpName() is new, it will return
     * an empty collection; or if this $table->getPhpName() has previously
     * been saved, it will retrieve related ${relCol} from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Category.
     */
    public function getImagesJoinCategory($criteria = null)
    {
		if ($criteria === null) {
            $criteria = new Criteria();
        }
		
        if ($this->collImages === null) {
            if ($this->isNew()) {
               $this->collImages = array();
            } else {
       
                $criteria->add(ImagePeer::CAT_ID, $this->getid());
                   $this->collImages = ImagePeer::doSelectJoinCategory($criteria);
            }
        } else {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            $newCriteria = true;
      
                $criteria->add(ImagePeer::CAT_ID, $this->getid());
               if (!isset($this->lastImagesCriteria) || !$this->lastImagesCriteria->equals($criteria)) {
                $this->collImages = ImagePeer::doSelectJoinCategory($criteria);
            }
        }
        $this->lastImagesCriteria = $criteria;

        return $this->collImages;
    }

    /**
     * Collection to store aggregation of collnewss      
     * @var array
     */
    protected $collnewss; 

    /**
     * Temporary storage of collnewss to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     * @return void
     */
    public function initnewss()
    {
        if ($this->collnewss === null) {
            $this->collnewss = array();
        }
    }

    /**
     * Method called to associate a news object to this object
     * through the news foreign key attribute
     *
     * @param news $l $className
     * @return void
     * @throws PropelException
     */
    public function addnews(news $l)
    {
        $this->collnewss[] = $l;
        $l->setCategory($this);
    }

    /**
     * The criteria used to select the current contents of collnewss.
     * @var Criteria
     */
    private $lastnewssCriteria = null;

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Category has previously
     * been saved, it will retrieve related ${relCol} from storage.
     * If this Category is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @param Criteria $criteria
     * @throws PropelException
     */
    public function getnewss($criteria = null)
    {
        if ($criteria === null) {
            $criteria = new Criteria();
        }
                
        if ($this->collnewss === null) {
            if ($this->isNew()) {
               $this->collnewss = array();
            } else {
    
                $criteria->add(newsPeer::CAT_ID, $this->getid() );

                $this->collnewss = newsPeer::doSelect($criteria);
            }
        } else {
            // criteria has no effect for a new object
            if (!$this->isNew()) {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.

                $criteria->add(newsPeer::CAT_ID, $this->getid());

                if (!isset($this->lastnewssCriteria) || !$this->lastnewssCriteria->equals($criteria)) {
                    $this->collnewss = newsPeer::doSelect($criteria);
                }
            }
        }
        $this->lastnewssCriteria = $criteria;

        return $this->collnewss;
    }
    

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this $table->getPhpName() is new, it will return
     * an empty collection; or if this $table->getPhpName() has previously
     * been saved, it will retrieve related ${relCol} from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Category.
     */
    public function getnewssJoinImage($criteria = null)
    {
		if ($criteria === null) {
            $criteria = new Criteria();
        }
		
        if ($this->collnewss === null) {
            if ($this->isNew()) {
               $this->collnewss = array();
            } else {
       
                $criteria->add(newsPeer::CAT_ID, $this->getid());
                   $this->collnewss = newsPeer::doSelectJoinImage($criteria);
            }
        } else {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            $newCriteria = true;
      
                $criteria->add(newsPeer::CAT_ID, $this->getid());
               if (!isset($this->lastnewssCriteria) || !$this->lastnewssCriteria->equals($criteria)) {
                $this->collnewss = newsPeer::doSelectJoinImage($criteria);
            }
        }
        $this->lastnewssCriteria = $criteria;

        return $this->collnewss;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this $table->getPhpName() is new, it will return
     * an empty collection; or if this $table->getPhpName() has previously
     * been saved, it will retrieve related ${relCol} from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Category.
     */
    public function getnewssJoinCategory($criteria = null)
    {
		if ($criteria === null) {
            $criteria = new Criteria();
        }
		
        if ($this->collnewss === null) {
            if ($this->isNew()) {
               $this->collnewss = array();
            } else {
       
                $criteria->add(newsPeer::CAT_ID, $this->getid());
                   $this->collnewss = newsPeer::doSelectJoinCategory($criteria);
            }
        } else {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            $newCriteria = true;
      
                $criteria->add(newsPeer::CAT_ID, $this->getid());
               if (!isset($this->lastnewssCriteria) || !$this->lastnewssCriteria->equals($criteria)) {
                $this->collnewss = newsPeer::doSelectJoinCategory($criteria);
            }
        }
        $this->lastnewssCriteria = $criteria;

        return $this->collnewss;
    }

    /**
     * Collection to store aggregation of collpages      
     * @var array
     */
    protected $collpages; 

    /**
     * Temporary storage of collpages to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     * @return void
     */
    public function initpages()
    {
        if ($this->collpages === null) {
            $this->collpages = array();
        }
    }

    /**
     * Method called to associate a page object to this object
     * through the page foreign key attribute
     *
     * @param page $l $className
     * @return void
     * @throws PropelException
     */
    public function addpage(page $l)
    {
        $this->collpages[] = $l;
        $l->setCategory($this);
    }

    /**
     * The criteria used to select the current contents of collpages.
     * @var Criteria
     */
    private $lastpagesCriteria = null;

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Category has previously
     * been saved, it will retrieve related ${relCol} from storage.
     * If this Category is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @param Criteria $criteria
     * @throws PropelException
     */
    public function getpages($criteria = null)
    {
        if ($criteria === null) {
            $criteria = new Criteria();
        }
                
        if ($this->collpages === null) {
            if ($this->isNew()) {
               $this->collpages = array();
            } else {
    
                $criteria->add(pagePeer::CAT_ID, $this->getid() );

                $this->collpages = pagePeer::doSelect($criteria);
            }
        } else {
            // criteria has no effect for a new object
            if (!$this->isNew()) {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.

                $criteria->add(pagePeer::CAT_ID, $this->getid());

                if (!isset($this->lastpagesCriteria) || !$this->lastpagesCriteria->equals($criteria)) {
                    $this->collpages = pagePeer::doSelect($criteria);
                }
            }
        }
        $this->lastpagesCriteria = $criteria;

        return $this->collpages;
    }
    

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this $table->getPhpName() is new, it will return
     * an empty collection; or if this $table->getPhpName() has previously
     * been saved, it will retrieve related ${relCol} from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Category.
     */
    public function getpagesJoinImage($criteria = null)
    {
		if ($criteria === null) {
            $criteria = new Criteria();
        }
		
        if ($this->collpages === null) {
            if ($this->isNew()) {
               $this->collpages = array();
            } else {
       
                $criteria->add(pagePeer::CAT_ID, $this->getid());
                   $this->collpages = pagePeer::doSelectJoinImage($criteria);
            }
        } else {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            $newCriteria = true;
      
                $criteria->add(pagePeer::CAT_ID, $this->getid());
               if (!isset($this->lastpagesCriteria) || !$this->lastpagesCriteria->equals($criteria)) {
                $this->collpages = pagePeer::doSelectJoinImage($criteria);
            }
        }
        $this->lastpagesCriteria = $criteria;

        return $this->collpages;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this $table->getPhpName() is new, it will return
     * an empty collection; or if this $table->getPhpName() has previously
     * been saved, it will retrieve related ${relCol} from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Category.
     */
    public function getpagesJoinCategory($criteria = null)
    {
		if ($criteria === null) {
            $criteria = new Criteria();
        }
		
        if ($this->collpages === null) {
            if ($this->isNew()) {
               $this->collpages = array();
            } else {
       
                $criteria->add(pagePeer::CAT_ID, $this->getid());
                   $this->collpages = pagePeer::doSelectJoinCategory($criteria);
            }
        } else {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            $newCriteria = true;
      
                $criteria->add(pagePeer::CAT_ID, $this->getid());
               if (!isset($this->lastpagesCriteria) || !$this->lastpagesCriteria->equals($criteria)) {
                $this->collpages = pagePeer::doSelectJoinCategory($criteria);
            }
        }
        $this->lastpagesCriteria = $criteria;

        return $this->collpages;
    }

    private $fieldNames;

    /**
     * Generate a list of field names.
     *
     * @return array A list of field names
     */
    public function getFieldNames()
    {
        if ($this->fieldNames === null) {
            $this->fieldNames = array("id", "title", "description", "image_id", "parent_id", "children", );
        }
        return $this->fieldNames;
    }

    /**
     * Retrieves a field from the object by name passed in as a String.
     *
     * @param string $name field name
     * @return mixed Value of field
     */
    public function getByName($name)
    {
        switch($name) {
        
            case "id":
                return $this->getid();
                break;
            
            case "title":
                return $this->gettitle();
                break;
            
            case "description":
                return $this->getdescription();
                break;
            
            case "image_id":
                return $this->getimage_id();
                break;
            
            case "parent_id":
                return $this->getparent_id();
                break;
            
            case "children":
                return $this->getchildren();
                break;
        
            default:
                return null;
        } // switch()
    }
    
    /**
     * Retrieves a field from the object by name passed in
     * as a string.  The string must be one of the static
     * strings defined in this Class' Peer.
     *
     * @param string $name peer name
     * @return mixed Value of field.
     */
    public function getByPeerName($name)
    {
        switch($name) {
      
            case CategoryPeer::ID:
                return $this->getid();
                break;
          
            case CategoryPeer::TITLE:
                return $this->gettitle();
                break;
          
            case CategoryPeer::DESCRIPTION:
                return $this->getdescription();
                break;
          
            case CategoryPeer::IMAGE_ID:
                return $this->getimage_id();
                break;
          
            case CategoryPeer::PARENT_ID:
                return $this->getparent_id();
                break;
          
            case CategoryPeer::CHILDREN:
                return $this->getchildren();
                break;
      
            default:
                return null;
                
        } // switch()
    }

    /**
     * Retrieves a field from the object by Position as specified
     * in the xml schema.  Zero-based.
     *
     * @param int $pos position in xml schema
     * @return mixed Value of field at $pos
     */
    public function getByPosition($pos)
    {
        switch($pos) {
  
            case 0:
                return $this->getid();
                break;
  
            case 1:
                return $this->gettitle();
                break;
  
            case 2:
                return $this->getdescription();
                break;
  
            case 3:
                return $this->getimage_id();
                break;
  
            case 4:
                return $this->getparent_id();
                break;
  
            case 5:
                return $this->getchildren();
                break;
            default:
                return null;
        } // switch()
    }



    
    /**
     * Sets a field value from the object by name passed in as a string.
     *
     * @param string $name field name
     * @param mixed $value field value
     * @return void
     */
    public function setByName($name, $value)
    {
        switch($name) {
        
            case "id":
                $this->setid($value);
                break;
            
            case "title":
                $this->settitle($value);
                break;
            
            case "description":
                $this->setdescription($value);
                break;
            
            case "image_id":
                $this->setimage_id($value);
                break;
            
            case "parent_id":
                $this->setparent_id($value);
                break;
            
            case "children":
                $this->setchildren($value);
                break;
        
        } // switch()
    }
    
    /**
     * Sets a field from the object by name passed in
     * as a string.  The string must be one of the static
     * strings defined in this Class' Peer.
     *
     * @param string $name peer name
     * @param mixed $value field value
     * @return void
     */
    public function setByPeerName($name, $value)
    {
        switch($name) {
      
            case CategoryPeer::ID:
                $this->setid($value);
                break;
          
            case CategoryPeer::TITLE:
                $this->settitle($value);
                break;
          
            case CategoryPeer::DESCRIPTION:
                $this->setdescription($value);
                break;
          
            case CategoryPeer::IMAGE_ID:
                $this->setimage_id($value);
                break;
          
            case CategoryPeer::PARENT_ID:
                $this->setparent_id($value);
                break;
          
            case CategoryPeer::CHILDREN:
                $this->setchildren($value);
                break;
                      
        } // switch()
    }

    /**
     * Sets a field from the object by Position as specified
     * in the xml schema.  Zero-based.
     *
     * @param int $pos position in xml schema
     * @param mixed $value field value
     * @return void
     */
    public function setByPosition($pos, $value)
    {
        switch($pos) {
  
            case 0:
                $this->setid($value);
                break;
  
            case 1:
                $this->settitle($value);
                break;
  
            case 2:
                $this->setdescription($value);
                break;
  
            case 3:
                $this->setimage_id($value);
                break;
  
            case 4:
                $this->setparent_id($value);
                break;
  
            case 5:
                $this->setchildren($value);
                break;
        } // switch()
    }


 
    /**
     * Removes this object from datastore and sets delete attribute.
     * 
     * @param Connection $con
     * @return void
     * @throws PropelException
     * @see BaseObject::setDeleted()
     * @see BaseObject::isDeleted()
     */
    public function delete($con = null)
    {    
        if ($this->isDeleted()) {
            throw new PropelException("This object has already been deleted.");
        }
        $tx_owner = false;
        if ($con === null) {
            $con = Transaction::begin(BaseCategoryPeer::DATABASE_NAME);
            $tx_owner = true;
        }
        
        try {
            CategoryPeer::doDelete($this, $con);
            $this->setDeleted(true);
            if ($tx_owner) Transaction::commit($con);
        } catch (PropelException $e) {
            if ($tx_owner) Transaction::rollback($con);
            throw $e;
        }
    }
    
   
    /**
     * flag to prevent endless save loop, if this object is referenced
     * by another object which falls in this transaction.
     * @var boolean
     */
    private $alreadyInSave = false;
  

    /**
     * Stores the object in the database.  If the object is new,
     * it inserts it; otherwise an update is performed.  This method
     * wraps the doSave() worker method in a transaction.
     *
     * @param Connection $con
     * @return void
     * @throws PropelException
     */
    public function save($con = null)
    {
        if ($this->isDeleted()) {
            throw new PropelException("You cannot save an object that has been deleted.");
        }
        
        $tx_owner = false; // we can only commit/rollback transactions we start
        if ($con === null) {
            $con = Transaction::begin(CategoryPeer::DATABASE_NAME);
            $tx_owner = true;
        }
        
        try {
            self::doSave($con);            
            if ($tx_owner) Transaction::commit($con);
        } catch (PropelException $e) {
            if ($tx_owner) Transaction::rollback($con);
            throw $e;
        }
    }
  
    /**
     * Stores the object in the database.  If the object is new,
     * it inserts it; otherwise an update is performed.
     *
     * @param Connection $con
     * @return void
     * @throws PropelException
     */
    protected function doSave($con) 
    {
        
         
        if (!$this->alreadyInSave) {
            $this->alreadyInSave = true;

            /*             
            FIXME! the following code can cause an infinite loop, needs more thought.
            
            [HL] I need to understand why exactly this would cause an infinte loop
            since we shouldn't have any problems with duplicate attempts to save the *same*
            object.
            */
        
            // We call the save method on the following object(s) if they
            // were passed to this object by their coresponding set
            // method.  This object relates to these object(s) by a
            // foreign key reference.
       
            if ($this->aImage !== null) {
                if ($this->aImage->isModified()) $this->aImage->save($con);
                $this->setImage($this->aImage);
            }
       
            if ($this->aCategoryRelatedByparent_id !== null) {
                if ($this->aCategoryRelatedByparent_id->isModified()) $this->aCategoryRelatedByparent_id->save($con);
                $this->setCategoryRelatedByparent_id($this->aCategoryRelatedByparent_id);
            }
          
  
            // If this object has been modified, then save it to the database.
            if ($this->isModified()) {
                if ($this->isNew()) {
                    $pk = CategoryPeer::doInsert($this, $con);
                    $this->setPrimaryKey($pk); // [HL] make sure new PK is stored to object.
                    $this->setNew(false);
                } else {
                    CategoryPeer::doUpdate($this, $con);
                }            
                $this->resetModified(); // [HL] After being saved an object is no longer 'modified'
            }
            if ($this->collDocuments !== null) {
                for ($i=0,$size=count($this->collDocuments); $i < $size; $i++) {
                    $this->collDocuments[$i]->save($con);
                }
              }
            if ($this->collFiles !== null) {
                for ($i=0,$size=count($this->collFiles); $i < $size; $i++) {
                    $this->collFiles[$i]->save($con);
                }
              }
            if ($this->collImages !== null) {
                for ($i=0,$size=count($this->collImages); $i < $size; $i++) {
                    $this->collImages[$i]->save($con);
                }
              }
            if ($this->collnewss !== null) {
                for ($i=0,$size=count($this->collnewss); $i < $size; $i++) {
                    $this->collnewss[$i]->save($con);
                }
              }
            if ($this->collpages !== null) {
                for ($i=0,$size=count($this->collpages); $i < $size; $i++) {
                    $this->collpages[$i]->save($con);
                }
              }

            $this->alreadyInSave = false;
        }
    }

    /**
     * Validates the objects modified field values.
     * This includes all objects related to this table.
     *
     * @return mixed <code>true</code> if all columns pass validation
     *              or an array of <code>ValidationFailed</code> objects for columns that fail.
     */
    public function validate()
    {
        return $this->doValidate();
    }
 
    /**
     * flag to prevent endless validation loop, if this object is referenced
     * by another object which falls in this transaction.
     * @var boolean
     */
    protected $alreadyInValidation = false;
  
    /**
     * This function performs the validation work for complex object models.
     * 
     * In addition to checking the current object, all related objects will
     * also be validated.  If all pass then <code>true</code> is returned; otherwise
     * an aggreagated array of ValidationFailed objects will be returned.
     *
     * @return mixed <code>true</code> if all validations pass; array of <code>ValidationFailed</code> objets otherwise.
     */
    protected function doValidate()
    {
        if (! $this->alreadyInValidation) {
            $this->alreadyInValidation = true;
            $retval = null;
      
            $failureMap = array();      
      
            // We call the validate method on the following object(s) if they
            // were passed to this object by their coresponding set
            // method.  This object relates to these object(s) by a
            // foreign key reference.
            if ($this->aImage !== null) {
                if (($retval = $this->aImage->validate()) !== true) {
                    $failureMap = array_merge($failureMap, $retval);
                }
            }
            if ($this->aCategoryRelatedByparent_id !== null) {
                if (($retval = $this->aCategoryRelatedByparent_id->validate()) !== true) {
                    $failureMap = array_merge($failureMap, $retval);
                }
            }

            if (($retval = CategoryPeer::doValidate($this)) !== true) {
                $failureMap = array_merge($failureMap, $retval);
            }
      
            if ($this->collDocuments !== null) {
                for ($i=0,$size=count($this->collDocuments); $i < $size; $i++) {
                    if (($retval = $this->collDocuments[$i]->validate()) !== true) {
                        $failureMap = array_merge($failureMap, $retval);
                    }
                }
            }
            if ($this->collFiles !== null) {
                for ($i=0,$size=count($this->collFiles); $i < $size; $i++) {
                    if (($retval = $this->collFiles[$i]->validate()) !== true) {
                        $failureMap = array_merge($failureMap, $retval);
                    }
                }
            }
            if ($this->collImages !== null) {
                for ($i=0,$size=count($this->collImages); $i < $size; $i++) {
                    if (($retval = $this->collImages[$i]->validate()) !== true) {
                        $failureMap = array_merge($failureMap, $retval);
                    }
                }
            }
            if ($this->collnewss !== null) {
                for ($i=0,$size=count($this->collnewss); $i < $size; $i++) {
                    if (($retval = $this->collnewss[$i]->validate()) !== true) {
                        $failureMap = array_merge($failureMap, $retval);
                    }
                }
            }
            if ($this->collpages !== null) {
                for ($i=0,$size=count($this->collpages); $i < $size; $i++) {
                    if (($retval = $this->collpages[$i]->validate()) !== true) {
                        $failureMap = array_merge($failureMap, $retval);
                    }
                }
            }
      
            $this->alreadyInValidation = false;
        }
    
        return (!empty($failureMap) ? $failureMap : true);
    }
  

    /**
     * Set the PrimaryKey.
     *
     * @param mixed id Primary key.
     * @return void
     * @throws PropelException     */
    public function setPrimaryKey($key) 
    {        
        $this->setid($key);
    }
    

    /**
     * Returns an id that differentiates this object from others
     * of its class.
     * @return int 
     */
    public function getPrimaryKey()
    {

        return $this->getid();

    }


    
    /**
     * Makes a copy of this object.
     * It creates a new object filling in the simple attributes.
     *  
     * It then fills all the association collections and sets the
     * related objects to isNew=true.
     *  
     * @return Category Clone of current object.
     * @throws PropelException
     */
    public function __clone() 
    {
        $copyObj = new Category();
 
        $copyObj->settitle($this->title);
 
        $copyObj->setdescription($this->description);
 
        $copyObj->setimage_id($this->image_id);
 
        $copyObj->setparent_id($this->parent_id);
 
        $copyObj->setchildren($this->children);

        $copyObj->setNew(false);

        $v = $this->getDocuments();
        for ($i=0,$size=count($v); $i < $size; $i++) {
            $obj = $v[$i];
            $copyObj->addDocument(clone $obj);
            $v[$i]->setNew(true);
        }
    
        $v = $this->getFiles();
        for ($i=0,$size=count($v); $i < $size; $i++) {
            $obj = $v[$i];
            $copyObj->addFile(clone $obj);
            $v[$i]->setNew(true);
        }
    
        $v = $this->getImages();
        for ($i=0,$size=count($v); $i < $size; $i++) {
            $obj = $v[$i];
            $copyObj->addImage(clone $obj);
            $v[$i]->setNew(true);
        }
    
        $v = $this->getnewss();
        for ($i=0,$size=count($v); $i < $size; $i++) {
            $obj = $v[$i];
            $copyObj->addnews(clone $obj);
            $v[$i]->setNew(true);
        }
    
        $v = $this->getpages();
        for ($i=0,$size=count($v); $i < $size; $i++) {
            $obj = $v[$i];
            $copyObj->addpage(clone $obj);
            $v[$i]->setNew(true);
        }
            
        $copyObj->setNew(true);
 
        $copyObj->setid('0'); // this is a pkey column, so set to default value

        return $copyObj;
    }
        

    /**
     * returns a peer instance associated with this om.  Since Peer classes    
     * are not to have any instance attributes, this method returns the
     * same instance for all member of this class. The method could therefore
     * be static, but this would prevent one from overriding the behavior.
     * @return CategoryPeer
     */
    public function getPeer()
    {
        if (self::$peer === null) {
            self::$peer = new CategoryPeer();
        }
        return self::$peer;
    }

}
