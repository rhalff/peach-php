<?php
require_once 'propel/util/BasePeer.php';

// The object class -- needed for instanceof checks in this class.
// actual class may be a subclass -- as returned by CategoryPeer::getOMClass()
include_once 'PEACH/Propel/Category.php';
	
include_once 'PEACH/Propel/Image.php';
include_once 'PEACH/Propel/ImagePeer.php';
	
include_once 'PEACH/Propel/Category.php';
include_once 'PEACH/Propel/CategoryPeer.php';

/**
 * This class was autogenerated by Propel on:
 *
 * [Fri Jun  4 20:26:28 2004]
 *
 * @package PEACH.Propel 
 */
abstract class BaseCategoryPeer extends BasePeer {

	/** the default database name for this class */
	const DATABASE_NAME = "PEACH";

	/** the table name for this class */
	const TABLE_NAME = "categories";

 
	/** the column name for the ID field */
	const ID = "categories.ID";
 
	/** the column name for the TITLE field */
	const TITLE = "categories.TITLE";
 
	/** the column name for the DESCRIPTION field */
	const DESCRIPTION = "categories.DESCRIPTION";
 
	/** the column name for the IMAGE_ID field */
	const IMAGE_ID = "categories.IMAGE_ID";
 
	/** the column name for the PARENT_ID field */
	const PARENT_ID = "categories.PARENT_ID";
 
	/** the column name for the CHILDREN field */
	const CHILDREN = "categories.CHILDREN";

	

	/** number of columns for this peer */
	public static $numColumns = 6;
	
	/** A class that can be returned by this peer. */
	const CLASS_DEFAULT = "PEACH.Propel.Category";

	/** The PHP to DB Name Mapping */
	private static $phpNameMap = null;

	/**
	 * @return MapBuilder the map builder for this peer
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function getMapBuilder()        
	{
		include_once 'PEACH/Propel/map/CategoryMapBuilder.php';
		return parent::getMapBuilder(CategoryMapBuilder::CLASS_NAME);
	}

	/**
	 * Gets a map (hash) of PHP names to DB column names.
	 *
	 * @return array The PHP to DB name map for this peer
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 * @todo Consider having template build the array rather than doing it at runtime.
	 */
	public static function getPhpNameMap()
	{
		if (self::$phpNameMap === null) {
			$map = self::getTableMap();
			$columns = $map->getColumns();
			$nameMap = array();
			foreach ($columns as $column) {
				$nameMap[$column->getPhpName()] = $column->getColumnName();
			}
			self::$phpNameMap = $nameMap;
		}
		return self::$phpNameMap;
	}
	
	/**
	 * Convenience method which changes table.column to alias.column.
	 *
	 * Using this method you can maintain SQL abstraction while using column aliases.
	 * <code>
	 *		$c->addAlias("alias1", TablePeer::TABLE_NAME);
	 *		$c->addJoin(TablePeer::alias("alias1", TablePeer::PRIMARY_KEY_COLUMN), TablePeer::PRIMARY_KEY_COLUMN);
	 * </code>
	 * @param string $alias The alias for the current table.
	 * @param string $column The column name for current table. (i.e. CategoryPeer::COLUMN_NAME).
	 * @return string
	 */
	public static function alias($alias, $column)
	{
		return $alias . substr($column, strlen(self::TABLE_NAME));
	}
	
	/**
	 * Add all the columns needed to create a new object.
	 *
	 * @param criteria object containing the columns to add.
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function addSelectColumns(Criteria $criteria)
	{
	 
		$criteria->addSelectColumn(self::ID);
	 
		$criteria->addSelectColumn(self::TITLE);
	 
		$criteria->addSelectColumn(self::DESCRIPTION);
	 
		$criteria->addSelectColumn(self::IMAGE_ID);
	 
		$criteria->addSelectColumn(self::PARENT_ID);
	 
		$criteria->addSelectColumn(self::CHILDREN);
		
	}

	/**
	 * Populates an object from a resultset row starting
	 * from a specified start column.  This is done so that you can select
	 * other rows than just those needed for this object.  You may
	 * for example want to create two objects from the same row.
	 *
     * @param ResultSet $rs The ResultSet to use for setting values.
	 * @param Category $obj The object to populate.
	 * @param int $startcol The column to start with (1 is first column).	 
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function populateObject(ResultSet $rs,Category $obj, $startcol = 1)
	{		
		
		try {
		 
			$obj->setid( $rs->getInt($startcol + 0) );					
					 
			$obj->settitle( $rs->getString($startcol + 1) );					
					 
			$obj->setdescription( $rs->getString($startcol + 2) );					
					 
			$obj->setimage_id( $rs->getInt($startcol + 3) );					
					 
			$obj->setparent_id( $rs->getInt($startcol + 4) );					
					 
			$obj->setchildren( $rs->getString($startcol + 5) );					
									
			 			
			$obj->resetModified();
			 			
			$obj->setNew(false);
		
		} catch (Exception $e) {
			throw new PropelException("Error populating object", $e);
		}
	}
    
    const COUNT = "COUNT(categories.ID)";
    const COUNT_DISTINCT = "COUNT(DISTINCT categories.ID)";
  
    /**
     * Returns the number of rows matching criteria.
     *
     * @param Criteria $criteria
     * @param boolean $distinct Whether to select only distinct columns.
     * @return int Number of matching rows.
     */
    function doCount(Criteria $criteria, $distinct = false)
    {   
        // we're going to modify criteria, so copy it first
        $criteria = clone $criteria;
        
        // clear out anything that might confuse the ORDER BY clause
        $criteria->clearSelectColumns()->clearOrderByColumns();
        if ($distinct) {
            $criteria->addSelectColumn(CategoryPeer::COUNT_DISTINCT);
        } else {
            $criteria->addSelectColumn(CategoryPeer::COUNT);    
        }
        
        $rs = CategoryPeer::doSelectRS($criteria);        
        $rs->next();
        return $rs->getInt(1);
    }
  
	/**
	 * Method to select one object from the DB.
	 *
	 * @param Criteria $criteria object used to create the SELECT statement.
	 * @param Connection $con
	 * @return Category	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function doSelectOne(Criteria $criteria, $con = null)
	{
		$critcopy = clone $criteria;
		$critcopy->setLimit(1);
		$objects = self::doSelect($critcopy, $con);
		if ($objects) {
			return $objects[0];
		}
		return null;
	}

	/**
	 * Method to do selects.
	 *
	 * @param mixed $criteria object used to create the SELECT statement.
	 * @param Connection $con
	 * @return array Array of selected Objects
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function doSelect($criteria, $con = null)
	{
		return self::populateObjects(self::doSelectRS($criteria, $con));
	}
	
	/**
	 * Prepares the Criteria object and uses the parent doSelect()
     * method to get a ResultSet.
     * 
	 * Use this method directly if you want to just get the resultset
     * (instead of an array of objects).
	 *
	 * @param mixed $criteria
	 * @param Connection $con the connection to use
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
     * @return ResultSet The resultset object with numerically-indexed fields.
     * @see parent::doSelect()
	 */
	public static function doSelectRS($criteria, $con = null)
	{
		if ($con === null) {
			$con = Propel::getConnection(self::DATABASE_NAME);
		}
		
		if (!($criteria instanceof Criteria)) {
			$criteria = self::buildCriteria($criteria);
		}

		if (!$criteria->getSelectColumns()) {
			self::addSelectColumns($criteria);
		}
	
		// Set the correct dbName if it has not been overridden
		if ($criteria->getDbName() == Propel::getDefaultDB()) {
			$criteria->setDbName(self::DATABASE_NAME);
		}
		
		// BasePeer returns a Creole ResultSet, set to return
		// rows indexed numerically.		   
		return parent::doSelect($criteria, $con);
	}

	/**
	 * The returned array will contain objects of the default type or
	 * objects that inherit from the default.
	 *
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function populateObjects(ResultSet $rs)
	{
		$results = array();
		
		// set the class once to avoid overhead in the loop
		$cls = CategoryPeer::getOMClass();
		$cls = Propel::import($cls);

		// populate the object(s)
		while($rs->next()) {
			
			$obj = new $cls();
			CategoryPeer::populateObject($rs, $obj);
			$results[] = $obj;
		}
		return $results;
	}



	/**
	 * The class that the Peer will make instances of.
	 * If the BO is abstract then you must implement this method
	 * in the BO.
	 *
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function getOMClass()
	{ 
		return self::CLASS_DEFAULT;
	 	
	}
 

	/**
	 * Method to do inserts.  This method is to be used during a transaction,
	 * otherwise use the doInsert(Criteria) method.  It will take care of
	 * the connection details internally.
	 *
	 * @param mixed $criteria object used to create the INSERT statement.
	 * @param Connection $con the connection to use
	 * @return mixed The new primary key.
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function doInsert($criteria, $con = null) {
		
		// use transaction because $criteria could contain info
		// for more than one table
		$tx_owner = false; // we can only commit/rollback transactions we start
		if ($con === null) {
			$con = Transaction::begin(self::DATABASE_NAME);
			$tx_owner = true;
		}
		
		if (!($criteria instanceof Criteria)) {
			$criteria = self::buildCriteria($criteria);
		}
		
		// Set the correct dbName if it has not been overridden
		// criteria.getDbName will return the same object if not set to
		// another value so == check is okay and faster
		if ($criteria->getDbName() == Propel::getDefaultDB()) {
			$criteria->setDbName(self::DATABASE_NAME);
		}
		
		try {
			$pk = parent::doInsert($criteria, $con);
			if ($tx_owner) Transaction::commit($con);
		} catch(PropelException $e) {
			if ($tx_owner) Transaction::rollback($con);
			throw $e;
		}
		
		return $pk;		
	}

	/**
	 * Method to do updates.
	 *
	 * @param mixed $values Criteria or Category object containing data that is used to create the UPDATE statement.
	 * @param Connection $con The connection to use (specify Connection object to exert more control over transactions).
	 * @return void
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function doUpdate($values, $con = null)
	{			
		if ($con === null) {
			$con = Propel::getConnection(self::DATABASE_NAME);
		}
		
        $selectCriteria = new Criteria(self::DATABASE_NAME);
                
        if ($values instanceof Criteria) {
            $criteria = $values;
    	 		
            $selectCriteria->put(self::ID, $criteria->remove(self::ID));
    	 
        } else {
            $criteria = self::buildCriteria($values);                        
            // for UPDATES we *always* want the primary key
            // to be part of the Criteria (buildCriteria() will not add pkey cols
            // unless they are modified)
         
            $selectCriteria->put(self::ID, $values->getid());
    	 
		}	

		// Set the correct dbName if it has not been overridden
		if ($criteria->getDbName() == Propel::getDefaultDB()) {
			$criteria->setDbName(self::DATABASE_NAME);
		}

		parent::doUpdate($selectCriteria, $criteria, $con);        
	}   
	
	/**
	 * Method to do deletes.
	 *
	 * @param mixed $values $values Criteria or Category object containing data that is used to create the DELETE statement.
	 * @param Connection $con the connection to use
	 * @return void
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	 public static function doDelete($values, $con = null)
	 {		
		// use transaction because $criteria could contain info
		// for more than one table or we could emulating ON DELETE CASCADE, etc.
		$tx_owner = false; // we can only commit/rollback transactions we start
		if ($con === null) {
			$con = Transaction::begin(self::DATABASE_NAME);
			$tx_owner = true;
		}		
		
        if ($values instanceof Criteria) {
            $criteria = $values;
		} else {
			$criteria = self::buildCriteria($values);
            
            if ($values instanceof Category) {
                // when using a Category object as the criteria
                // for a DELETE we want to ensure that the primary key is included in the Criteria
                // as it may be left out by buildCriteria() (e.g. if it wasn't modified).
             
                $criteria->put(self::ID, $values->getid());
        	 
            }
		}
			 
		// Set the correct dbName if it has not been overridden
		if ($criteria->getDbName() == Propel::getDefaultDB()) {
			$criteria->setDbName(self::DATABASE_NAME);
		}
		
		try { 
			parent::doDelete($criteria, $con);
			if ($tx_owner) Transaction::commit($con);
		} catch (PropelException $e) {
			if ($tx_owner) Transaction::rollback($con);
			throw $e;
		}		
	}	

	
	/**
	 * Validates all modified columns of given Category object.
	 *
	 * NOTICE: This does not apply to primary or foreign keys for now.
	 *
	 * @param Category $obj The object to validate.
	 * @return mixed TRUE if all columns are valid or the error message of the first invalid column.
	 */
	public static function doValidate(Category $obj)
	{		
		$columns = array();
		return parent::doValidate(self::DATABASE_NAME, self::TABLE_NAME, $columns);
	}

  
  /**
	 * Build a Criteria object from the data object for this peer or from primary key(s).
	 *
	 * @param mixed $obj Category object or scalar primary key.
	 * @return Criteria The compiled Criteria object.
	 */
	public static function buildCriteria($obj)
	{
		if ($obj instanceof Category ) {
			$criteria = new Criteria(self::DATABASE_NAME);
			 
			if ($obj->isColumnModified(self::ID)) $criteria->add(self::ID, $obj->getid());
			 
			if ($obj->isColumnModified(self::TITLE)) $criteria->add(self::TITLE, $obj->gettitle());
			 
			if ($obj->isColumnModified(self::DESCRIPTION)) $criteria->add(self::DESCRIPTION, $obj->getdescription());
			 
			if ($obj->isColumnModified(self::IMAGE_ID)) $criteria->add(self::IMAGE_ID, $obj->getimage_id());
			 
			if ($obj->isColumnModified(self::PARENT_ID)) $criteria->add(self::PARENT_ID, $obj->getparent_id());
			 
			if ($obj->isColumnModified(self::CHILDREN)) $criteria->add(self::CHILDREN, $obj->getchildren());
						
		} else {
			// it must be the primary key
			$criteria = new Criteria(self::DATABASE_NAME);
		  		
			$criteria->add(self::ID, $obj);
		  							
		}
		
		return $criteria;
	}    	 


	/**
	 * Retrieve a single object by pkey.
	 *
	 * @param mixed $pk the primary key.
	 * @param Connection $con the connection to use
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function retrieveByPK($pk, $con = null)
	{		
		if ($con === null) {
			$con = Propel::getConnection(self::DATABASE_NAME);
		}

		$criteria = self::buildCriteria($pk);
		$v = self::doSelect($criteria, $con);
		if (count($v) != 1) {
			throw new PropelException("Failed to select one and only one row.");
		} else {
			return $v[0];
		}
	}

	/**
	 * Retrieve multiple objects by pkey.
	 *
	 * @param array $pks List of primary keys
	 * @param Connection $con the connection to use
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function retrieveByPKs($pks, $con = null)
	{
		if ($con === null) {
			$con = Propel::getConnection(self::DATABASE_NAME);
		}
		
		$objs = null;
		if (empty($pks)) {
			$objs = array();
		} else {
			$criteria = new Criteria();
    
			$criteria->add(self::ID, $pks, Criteria::IN);
    
			$objs = self::doSelect($criteria, $con);
		}
		return $objs;
	}

 

	/**
	 * Selects a collection of Category objects pre-filled with their
	 * Image objects.
	 *
	 * @return array Array of Category objects.
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function doSelectJoinImage(Criteria $c)
	{

		// Set the correct dbName if it has not been overridden
		if ($c->getDbName() == Propel::getDefaultDB()) {
			$c->setDbName(self::DATABASE_NAME);
		}

		CategoryPeer::addSelectColumns($c);
		$startcol = self::$numColumns + 1;
		ImagePeer::addSelectColumns($c);

			$c->addJoin(CategoryPeer::IMAGE_ID, ImagePeer::ID);
	 
		$rs = parent::doSelect($c);
		$results = array();

		while($rs->next()) {
			$omClass = CategoryPeer::getOMClass();
			$cls = Propel::import($omClass);
			$obj1 = new $cls();
			CategoryPeer::populateObject($rs, $obj1);


			$omClass = ImagePeer::getOMClass();
			$cls = Propel::import($omClass);
			$obj2 = new $cls();
			ImagePeer::populateObject($rs, $obj2, $startcol);

			$newObject = true;
			foreach($results as $temp_obj1) {
				$temp_obj2 = $temp_obj1->getImage();
				if ($temp_obj2->getPrimaryKey() === $obj2->getPrimaryKey()) {
					$newObject = false;
					$temp_obj2->addCategory($obj1);
					break;
				}
			}
			if ($newObject) {
				$obj2->initCategorys();
				$obj2->addCategory($obj1);
			}
			$results[] = $obj1;
		}
		return $results;
	}
	/**
	 * Returns the TableMap related to this peer.  This method is not
	 * needed for general use but a specific application could have a need.
	 * @return TableMap
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	protected static function getTableMap()
	{
		return Propel::getDatabaseMap(self::DATABASE_NAME)->getTable(self::TABLE_NAME);
	}
	
}

// static code to register the map builder for this Peer with the main Propel 
// class even if Propel is not yet initialized.
if (Propel::isInit()) {
	try {		
		BaseCategoryPeer::getMapBuilder();
	} catch (Exception $e) {
		Propel::logger()->err("Could not initialize Peer: " . $e->getMessage());
	}
} else {
	require_once 'PEACH/Propel/map/CategoryMapBuilder.php';
	Propel::registerMapBuilder(CategoryMapBuilder::CLASS_NAME);
}
