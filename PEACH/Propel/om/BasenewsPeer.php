<?php
require_once 'propel/util/BasePeer.php';

// The object class -- needed for instanceof checks in this class.
// actual class may be a subclass -- as returned by newsPeer::getOMClass()
include_once 'PEACH/Propel/news.php';
	
include_once 'PEACH/Propel/Image.php';
include_once 'PEACH/Propel/ImagePeer.php';
	
include_once 'PEACH/Propel/Category.php';
include_once 'PEACH/Propel/CategoryPeer.php';

/**
 * This class was autogenerated by Propel on:
 *
 * [Fri Jun  4 20:26:28 2004]
 *
 * @package PEACH.Propel 
 */
abstract class BasenewsPeer extends BasePeer {

	/** the default database name for this class */
	const DATABASE_NAME = "PEACH";

	/** the table name for this class */
	const TABLE_NAME = "news";

 
	/** the column name for the ID field */
	const ID = "news.ID";
 
	/** the column name for the SUBJECT field */
	const SUBJECT = "news.SUBJECT";
 
	/** the column name for the SUMMARY field */
	const SUMMARY = "news.SUMMARY";
 
	/** the column name for the BODY field */
	const BODY = "news.BODY";
 
	/** the column name for the IMAGE_ID field */
	const IMAGE_ID = "news.IMAGE_ID";
 
	/** the column name for the HITS field */
	const HITS = "news.HITS";
 
	/** the column name for the APPROVED field */
	const APPROVED = "news.APPROVED";
 
	/** the column name for the ACTIVE field */
	const ACTIVE = "news.ACTIVE";
 
	/** the column name for the COMMENTS field */
	const COMMENTS = "news.COMMENTS";
 
	/** the column name for the ANONYMOUS field */
	const ANONYMOUS = "news.ANONYMOUS";
 
	/** the column name for the USERCREATED field */
	const USERCREATED = "news.USERCREATED";
 
	/** the column name for the USERUPDATED field */
	const USERUPDATED = "news.USERUPDATED";
 
	/** the column name for the DATECREATED field */
	const DATECREATED = "news.DATECREATED";
 
	/** the column name for the DATEUPDATED field */
	const DATEUPDATED = "news.DATEUPDATED";
 
	/** the column name for the POSTON field */
	const POSTON = "news.POSTON";
 
	/** the column name for the EXPIRATION field */
	const EXPIRATION = "news.EXPIRATION";
 
	/** the column name for the CAT_ID field */
	const CAT_ID = "news.CAT_ID";

	

	/** number of columns for this peer */
	public static $numColumns = 17;
	
	/** A class that can be returned by this peer. */
	const CLASS_DEFAULT = "PEACH.Propel.news";

	/** The PHP to DB Name Mapping */
	private static $phpNameMap = null;

	/**
	 * @return MapBuilder the map builder for this peer
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function getMapBuilder()        
	{
		include_once 'PEACH/Propel/map/newsMapBuilder.php';
		return parent::getMapBuilder(newsMapBuilder::CLASS_NAME);
	}

	/**
	 * Gets a map (hash) of PHP names to DB column names.
	 *
	 * @return array The PHP to DB name map for this peer
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 * @todo Consider having template build the array rather than doing it at runtime.
	 */
	public static function getPhpNameMap()
	{
		if (self::$phpNameMap === null) {
			$map = self::getTableMap();
			$columns = $map->getColumns();
			$nameMap = array();
			foreach ($columns as $column) {
				$nameMap[$column->getPhpName()] = $column->getColumnName();
			}
			self::$phpNameMap = $nameMap;
		}
		return self::$phpNameMap;
	}
	
	/**
	 * Convenience method which changes table.column to alias.column.
	 *
	 * Using this method you can maintain SQL abstraction while using column aliases.
	 * <code>
	 *		$c->addAlias("alias1", TablePeer::TABLE_NAME);
	 *		$c->addJoin(TablePeer::alias("alias1", TablePeer::PRIMARY_KEY_COLUMN), TablePeer::PRIMARY_KEY_COLUMN);
	 * </code>
	 * @param string $alias The alias for the current table.
	 * @param string $column The column name for current table. (i.e. newsPeer::COLUMN_NAME).
	 * @return string
	 */
	public static function alias($alias, $column)
	{
		return $alias . substr($column, strlen(self::TABLE_NAME));
	}
	
	/**
	 * Add all the columns needed to create a new object.
	 *
	 * @param criteria object containing the columns to add.
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function addSelectColumns(Criteria $criteria)
	{
	 
		$criteria->addSelectColumn(self::ID);
	 
		$criteria->addSelectColumn(self::SUBJECT);
	 
		$criteria->addSelectColumn(self::SUMMARY);
	 
		$criteria->addSelectColumn(self::BODY);
	 
		$criteria->addSelectColumn(self::IMAGE_ID);
	 
		$criteria->addSelectColumn(self::HITS);
	 
		$criteria->addSelectColumn(self::APPROVED);
	 
		$criteria->addSelectColumn(self::ACTIVE);
	 
		$criteria->addSelectColumn(self::COMMENTS);
	 
		$criteria->addSelectColumn(self::ANONYMOUS);
	 
		$criteria->addSelectColumn(self::USERCREATED);
	 
		$criteria->addSelectColumn(self::USERUPDATED);
	 
		$criteria->addSelectColumn(self::DATECREATED);
	 
		$criteria->addSelectColumn(self::DATEUPDATED);
	 
		$criteria->addSelectColumn(self::POSTON);
	 
		$criteria->addSelectColumn(self::EXPIRATION);
	 
		$criteria->addSelectColumn(self::CAT_ID);
		
	}

	/**
	 * Populates an object from a resultset row starting
	 * from a specified start column.  This is done so that you can select
	 * other rows than just those needed for this object.  You may
	 * for example want to create two objects from the same row.
	 *
     * @param ResultSet $rs The ResultSet to use for setting values.
	 * @param news $obj The object to populate.
	 * @param int $startcol The column to start with (1 is first column).	 
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function populateObject(ResultSet $rs,news $obj, $startcol = 1)
	{		
		
		try {
		 
			$obj->setid( $rs->getInt($startcol + 0) );					
					 
			$obj->setsubject( $rs->getString($startcol + 1) );					
					 
			$obj->setsummary( $rs->getString($startcol + 2) );					
					 
			$obj->setbody( $rs->getString($startcol + 3) );					
					 
			$obj->setimage_id( $rs->getInt($startcol + 4) );					
					 
			$obj->sethits( $rs->getInt($startcol + 5) );					
					 
			$obj->setapproved( $rs->getInt($startcol + 6) );					
					 
			$obj->setactive( $rs->getInt($startcol + 7) );					
					 
			$obj->setcomments( $rs->getInt($startcol + 8) );					
					 
			$obj->setanonymous( $rs->getInt($startcol + 9) );					
					 
			$obj->setuserCreated( $rs->getString($startcol + 10) );					
					 
			$obj->setuserUpdated( $rs->getString($startcol + 11) );					
					 
            $obj->setdateCreated( $rs->getTimestamp($startcol + 12, null) );
					 
            $obj->setdateUpdated( $rs->getTimestamp($startcol + 13, null) );
					 
            $obj->setposton( $rs->getTimestamp($startcol + 14, null) );
					 
            $obj->setexpiration( $rs->getTimestamp($startcol + 15, null) );
					 
			$obj->setcat_id( $rs->getInt($startcol + 16) );					
									
			 			
			$obj->resetModified();
			 			
			$obj->setNew(false);
		
		} catch (Exception $e) {
			throw new PropelException("Error populating object", $e);
		}
	}
    
    const COUNT = "COUNT(news.ID)";
    const COUNT_DISTINCT = "COUNT(DISTINCT news.ID)";
  
    /**
     * Returns the number of rows matching criteria.
     *
     * @param Criteria $criteria
     * @param boolean $distinct Whether to select only distinct columns.
     * @return int Number of matching rows.
     */
    function doCount(Criteria $criteria, $distinct = false)
    {   
        // we're going to modify criteria, so copy it first
        $criteria = clone $criteria;
        
        // clear out anything that might confuse the ORDER BY clause
        $criteria->clearSelectColumns()->clearOrderByColumns();
        if ($distinct) {
            $criteria->addSelectColumn(newsPeer::COUNT_DISTINCT);
        } else {
            $criteria->addSelectColumn(newsPeer::COUNT);    
        }
        
        $rs = newsPeer::doSelectRS($criteria);        
        $rs->next();
        return $rs->getInt(1);
    }
  
	/**
	 * Method to select one object from the DB.
	 *
	 * @param Criteria $criteria object used to create the SELECT statement.
	 * @param Connection $con
	 * @return news	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function doSelectOne(Criteria $criteria, $con = null)
	{
		$critcopy = clone $criteria;
		$critcopy->setLimit(1);
		$objects = self::doSelect($critcopy, $con);
		if ($objects) {
			return $objects[0];
		}
		return null;
	}

	/**
	 * Method to do selects.
	 *
	 * @param mixed $criteria object used to create the SELECT statement.
	 * @param Connection $con
	 * @return array Array of selected Objects
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function doSelect($criteria, $con = null)
	{
		return self::populateObjects(self::doSelectRS($criteria, $con));
	}
	
	/**
	 * Prepares the Criteria object and uses the parent doSelect()
     * method to get a ResultSet.
     * 
	 * Use this method directly if you want to just get the resultset
     * (instead of an array of objects).
	 *
	 * @param mixed $criteria
	 * @param Connection $con the connection to use
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
     * @return ResultSet The resultset object with numerically-indexed fields.
     * @see parent::doSelect()
	 */
	public static function doSelectRS($criteria, $con = null)
	{
		if ($con === null) {
			$con = Propel::getConnection(self::DATABASE_NAME);
		}
		
		if (!($criteria instanceof Criteria)) {
			$criteria = self::buildCriteria($criteria);
		}

		if (!$criteria->getSelectColumns()) {
			self::addSelectColumns($criteria);
		}
	
		// Set the correct dbName if it has not been overridden
		if ($criteria->getDbName() == Propel::getDefaultDB()) {
			$criteria->setDbName(self::DATABASE_NAME);
		}
		
		// BasePeer returns a Creole ResultSet, set to return
		// rows indexed numerically.		   
		return parent::doSelect($criteria, $con);
	}

	/**
	 * The returned array will contain objects of the default type or
	 * objects that inherit from the default.
	 *
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function populateObjects(ResultSet $rs)
	{
		$results = array();
		
		// set the class once to avoid overhead in the loop
		$cls = newsPeer::getOMClass();
		$cls = Propel::import($cls);

		// populate the object(s)
		while($rs->next()) {
			
			$obj = new $cls();
			newsPeer::populateObject($rs, $obj);
			$results[] = $obj;
		}
		return $results;
	}



	/**
	 * The class that the Peer will make instances of.
	 * If the BO is abstract then you must implement this method
	 * in the BO.
	 *
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function getOMClass()
	{ 
		return self::CLASS_DEFAULT;
	 	
	}
 

	/**
	 * Method to do inserts.  This method is to be used during a transaction,
	 * otherwise use the doInsert(Criteria) method.  It will take care of
	 * the connection details internally.
	 *
	 * @param mixed $criteria object used to create the INSERT statement.
	 * @param Connection $con the connection to use
	 * @return mixed The new primary key.
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function doInsert($criteria, $con = null) {
		
		// use transaction because $criteria could contain info
		// for more than one table
		$tx_owner = false; // we can only commit/rollback transactions we start
		if ($con === null) {
			$con = Transaction::begin(self::DATABASE_NAME);
			$tx_owner = true;
		}
		
		if (!($criteria instanceof Criteria)) {
			$criteria = self::buildCriteria($criteria);
		}
		
		// Set the correct dbName if it has not been overridden
		// criteria.getDbName will return the same object if not set to
		// another value so == check is okay and faster
		if ($criteria->getDbName() == Propel::getDefaultDB()) {
			$criteria->setDbName(self::DATABASE_NAME);
		}
		
		try {
			$pk = parent::doInsert($criteria, $con);
			if ($tx_owner) Transaction::commit($con);
		} catch(PropelException $e) {
			if ($tx_owner) Transaction::rollback($con);
			throw $e;
		}
		
		return $pk;		
	}

	/**
	 * Method to do updates.
	 *
	 * @param mixed $values Criteria or news object containing data that is used to create the UPDATE statement.
	 * @param Connection $con The connection to use (specify Connection object to exert more control over transactions).
	 * @return void
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function doUpdate($values, $con = null)
	{			
		if ($con === null) {
			$con = Propel::getConnection(self::DATABASE_NAME);
		}
		
        $selectCriteria = new Criteria(self::DATABASE_NAME);
                
        if ($values instanceof Criteria) {
            $criteria = $values;
    	 		
            $selectCriteria->put(self::ID, $criteria->remove(self::ID));
    	 
        } else {
            $criteria = self::buildCriteria($values);                        
            // for UPDATES we *always* want the primary key
            // to be part of the Criteria (buildCriteria() will not add pkey cols
            // unless they are modified)
         
            $selectCriteria->put(self::ID, $values->getid());
    	 
		}	

		// Set the correct dbName if it has not been overridden
		if ($criteria->getDbName() == Propel::getDefaultDB()) {
			$criteria->setDbName(self::DATABASE_NAME);
		}

		parent::doUpdate($selectCriteria, $criteria, $con);        
	}   
	
	/**
	 * Method to do deletes.
	 *
	 * @param mixed $values $values Criteria or news object containing data that is used to create the DELETE statement.
	 * @param Connection $con the connection to use
	 * @return void
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	 public static function doDelete($values, $con = null)
	 {		
		// use transaction because $criteria could contain info
		// for more than one table or we could emulating ON DELETE CASCADE, etc.
		$tx_owner = false; // we can only commit/rollback transactions we start
		if ($con === null) {
			$con = Transaction::begin(self::DATABASE_NAME);
			$tx_owner = true;
		}		
		
        if ($values instanceof Criteria) {
            $criteria = $values;
		} else {
			$criteria = self::buildCriteria($values);
            
            if ($values instanceof news) {
                // when using a news object as the criteria
                // for a DELETE we want to ensure that the primary key is included in the Criteria
                // as it may be left out by buildCriteria() (e.g. if it wasn't modified).
             
                $criteria->put(self::ID, $values->getid());
        	 
            }
		}
			 
		// Set the correct dbName if it has not been overridden
		if ($criteria->getDbName() == Propel::getDefaultDB()) {
			$criteria->setDbName(self::DATABASE_NAME);
		}
		
		try { 
			parent::doDelete($criteria, $con);
			if ($tx_owner) Transaction::commit($con);
		} catch (PropelException $e) {
			if ($tx_owner) Transaction::rollback($con);
			throw $e;
		}		
	}	

	
	/**
	 * Validates all modified columns of given news object.
	 *
	 * NOTICE: This does not apply to primary or foreign keys for now.
	 *
	 * @param news $obj The object to validate.
	 * @return mixed TRUE if all columns are valid or the error message of the first invalid column.
	 */
	public static function doValidate(news $obj)
	{		
		$columns = array();
		return parent::doValidate(self::DATABASE_NAME, self::TABLE_NAME, $columns);
	}

  
  /**
	 * Build a Criteria object from the data object for this peer or from primary key(s).
	 *
	 * @param mixed $obj news object or scalar primary key.
	 * @return Criteria The compiled Criteria object.
	 */
	public static function buildCriteria($obj)
	{
		if ($obj instanceof news ) {
			$criteria = new Criteria(self::DATABASE_NAME);
			 
			if ($obj->isColumnModified(self::ID)) $criteria->add(self::ID, $obj->getid());
			 
			if ($obj->isColumnModified(self::SUBJECT)) $criteria->add(self::SUBJECT, $obj->getsubject());
			 
			if ($obj->isColumnModified(self::SUMMARY)) $criteria->add(self::SUMMARY, $obj->getsummary());
			 
			if ($obj->isColumnModified(self::BODY)) $criteria->add(self::BODY, $obj->getbody());
			 
			if ($obj->isColumnModified(self::IMAGE_ID)) $criteria->add(self::IMAGE_ID, $obj->getimage_id());
			 
			if ($obj->isColumnModified(self::HITS)) $criteria->add(self::HITS, $obj->gethits());
			 
			if ($obj->isColumnModified(self::APPROVED)) $criteria->add(self::APPROVED, $obj->getapproved());
			 
			if ($obj->isColumnModified(self::ACTIVE)) $criteria->add(self::ACTIVE, $obj->getactive());
			 
			if ($obj->isColumnModified(self::COMMENTS)) $criteria->add(self::COMMENTS, $obj->getcomments());
			 
			if ($obj->isColumnModified(self::ANONYMOUS)) $criteria->add(self::ANONYMOUS, $obj->getanonymous());
			 
			if ($obj->isColumnModified(self::USERCREATED)) $criteria->add(self::USERCREATED, $obj->getuserCreated());
			 
			if ($obj->isColumnModified(self::USERUPDATED)) $criteria->add(self::USERUPDATED, $obj->getuserUpdated());
			 
			if ($obj->isColumnModified(self::DATECREATED)) $criteria->add(self::DATECREATED, $obj->getdateCreated());
			 
			if ($obj->isColumnModified(self::DATEUPDATED)) $criteria->add(self::DATEUPDATED, $obj->getdateUpdated());
			 
			if ($obj->isColumnModified(self::POSTON)) $criteria->add(self::POSTON, $obj->getposton());
			 
			if ($obj->isColumnModified(self::EXPIRATION)) $criteria->add(self::EXPIRATION, $obj->getexpiration());
			 
			if ($obj->isColumnModified(self::CAT_ID)) $criteria->add(self::CAT_ID, $obj->getcat_id());
						
		} else {
			// it must be the primary key
			$criteria = new Criteria(self::DATABASE_NAME);
		  		
			$criteria->add(self::ID, $obj);
		  							
		}
		
		return $criteria;
	}    	 


	/**
	 * Retrieve a single object by pkey.
	 *
	 * @param mixed $pk the primary key.
	 * @param Connection $con the connection to use
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function retrieveByPK($pk, $con = null)
	{		
		if ($con === null) {
			$con = Propel::getConnection(self::DATABASE_NAME);
		}

		$criteria = self::buildCriteria($pk);
		$v = self::doSelect($criteria, $con);
		if (count($v) != 1) {
			throw new PropelException("Failed to select one and only one row.");
		} else {
			return $v[0];
		}
	}

	/**
	 * Retrieve multiple objects by pkey.
	 *
	 * @param array $pks List of primary keys
	 * @param Connection $con the connection to use
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function retrieveByPKs($pks, $con = null)
	{
		if ($con === null) {
			$con = Propel::getConnection(self::DATABASE_NAME);
		}
		
		$objs = null;
		if (empty($pks)) {
			$objs = array();
		} else {
			$criteria = new Criteria();
    
			$criteria->add(self::ID, $pks, Criteria::IN);
    
			$objs = self::doSelect($criteria, $con);
		}
		return $objs;
	}

 

	/**
	 * Selects a collection of news objects pre-filled with their
	 * Image objects.
	 *
	 * @return array Array of news objects.
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function doSelectJoinImage(Criteria $c)
	{

		// Set the correct dbName if it has not been overridden
		if ($c->getDbName() == Propel::getDefaultDB()) {
			$c->setDbName(self::DATABASE_NAME);
		}

		newsPeer::addSelectColumns($c);
		$startcol = self::$numColumns + 1;
		ImagePeer::addSelectColumns($c);

			$c->addJoin(newsPeer::IMAGE_ID, ImagePeer::ID);
	 
		$rs = parent::doSelect($c);
		$results = array();

		while($rs->next()) {
			$omClass = newsPeer::getOMClass();
			$cls = Propel::import($omClass);
			$obj1 = new $cls();
			newsPeer::populateObject($rs, $obj1);


			$omClass = ImagePeer::getOMClass();
			$cls = Propel::import($omClass);
			$obj2 = new $cls();
			ImagePeer::populateObject($rs, $obj2, $startcol);

			$newObject = true;
			foreach($results as $temp_obj1) {
				$temp_obj2 = $temp_obj1->getImage();
				if ($temp_obj2->getPrimaryKey() === $obj2->getPrimaryKey()) {
					$newObject = false;
					$temp_obj2->addnews($obj1);
					break;
				}
			}
			if ($newObject) {
				$obj2->initnewss();
				$obj2->addnews($obj1);
			}
			$results[] = $obj1;
		}
		return $results;
	}
	/**
	 * Selects a collection of news objects pre-filled with their
	 * Category objects.
	 *
	 * @return array Array of news objects.
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	public static function doSelectJoinCategory(Criteria $c)
	{

		// Set the correct dbName if it has not been overridden
		if ($c->getDbName() == Propel::getDefaultDB()) {
			$c->setDbName(self::DATABASE_NAME);
		}

		newsPeer::addSelectColumns($c);
		$startcol = self::$numColumns + 1;
		CategoryPeer::addSelectColumns($c);

			$c->addJoin(newsPeer::CAT_ID, CategoryPeer::ID);
	 
		$rs = parent::doSelect($c);
		$results = array();

		while($rs->next()) {
			$omClass = newsPeer::getOMClass();
			$cls = Propel::import($omClass);
			$obj1 = new $cls();
			newsPeer::populateObject($rs, $obj1);


			$omClass = CategoryPeer::getOMClass();
			$cls = Propel::import($omClass);
			$obj2 = new $cls();
			CategoryPeer::populateObject($rs, $obj2, $startcol);

			$newObject = true;
			foreach($results as $temp_obj1) {
				$temp_obj2 = $temp_obj1->getCategory();
				if ($temp_obj2->getPrimaryKey() === $obj2->getPrimaryKey()) {
					$newObject = false;
					$temp_obj2->addnews($obj1);
					break;
				}
			}
			if ($newObject) {
				$obj2->initnewss();
				$obj2->addnews($obj1);
			}
			$results[] = $obj1;
		}
		return $results;
	}
	/**
	 * Returns the TableMap related to this peer.  This method is not
	 * needed for general use but a specific application could have a need.
	 * @return TableMap
	 * @throws PropelException Any exceptions caught during processing will be
	 *         rethrown wrapped into a PropelException.
	 */
	protected static function getTableMap()
	{
		return Propel::getDatabaseMap(self::DATABASE_NAME)->getTable(self::TABLE_NAME);
	}
	
}

// static code to register the map builder for this Peer with the main Propel 
// class even if Propel is not yet initialized.
if (Propel::isInit()) {
	try {		
		BasenewsPeer::getMapBuilder();
	} catch (Exception $e) {
		Propel::logger()->err("Could not initialize Peer: " . $e->getMessage());
	}
} else {
	require_once 'PEACH/Propel/map/newsMapBuilder.php';
	Propel::registerMapBuilder(newsMapBuilder::CLASS_NAME);
}
